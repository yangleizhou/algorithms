package exchange

//双向扫描

// 退出循环后，有两种情况：i=j和i>j
// 这时需要确定左边和右边的边界
// 如果i>j,则i=j+1, 边界[j或i-1是左边的右边界，j+1或i是右边的左边界;i划入右半部分，j划入左半部分]

// 如果i=j，a[i/j]=pivot，

//[选取枢纽元放在最右边位置上
// 2.1 因为我们是选择最右边位置作为枢纽元位置，所以一开始i就停了下来
// 而j可能一直移动过来
// 如果选择最右边位置作为枢纽元，不会出现j一直移动到左边，而i一直不动
// 因为一开始j就不移动，如果j移动了，那么i必定移动，如果i移动j不一定移动
// 所以不会出现右边占据n-1个元素的情况
// 如果右边出现n-1个元素，则是因为选择最左边的位置作为枢纽元的位置
// 所以，为了避免死循环，a[i/j]应该划分到右边，因为这是选择的最后的位置作为的枢纽元的位置
// 这时j-1或i-1为左边的右边界，j或i为右边的左边界

// 2.2综上所述，左右部分边界的表示如果有i表示
// 则需要考虑i与j的关系，如果i=j，则i-1,i为右左边界
// 如果i>j，则i-1,i为右左边界
// 如果用j来表示左右部分的边界则：
// 如果i=j，则j-1,j为右左边界
// 如果i>j，则j,j+1为右左边界

// 2.3所以如果我们采用j表示边界，需要根据情况选择合适的，并不一致
// 如果我们选择i表示边界，则表示形式上是统一的
// 所以我们选择i-1作为左边的右边界，i作为右边的左边界]

//[选取枢纽元放在第一个位置上
// 2.1 因为我们是选择第一个位置作为枢纽元位置，所以一开始i就停了下来
// 而j可能一直移动过来
// 如果选择第一个位置作为枢纽元，不会出现i一直移动到最右边，而j一直不动
// 因为一开始i就不移动，如果i移动了，那么j必定移动，如果j移动i不一定移动
// 所以不会出现左边占据n-1个元素的情况
// 如果左边出现n-1个元素，则是因为选择最右边的位置作为枢纽元的位置
// 所以，为了避免死循环，a[i/j]应该划分到左边，因为这是选择的最左边的位置作为的枢纽元的位置
// 这时j或i为左边的右边界，j+1或i+1为右边的左边界

// 2.2综上所述，左右部分边界的表示如果有i表示
// 则需要考虑i与j的关系，如果i=j，则i-1,i为右左边界
// 如果i>j，则i,i+1为右左边界
// 如果用j来表示左右部分的边界则：
// 如果i=j，则j,j+1为右左边界
// 如果i>j，则j,j+1为右左边界

// 2.3所以如果我们采用i表示边界，需要根据情况选择合适的，并不一致
// 如果我们选择j表示边界，则表示形式上是统一的
// 所以我们选择j作为左边的右边界，j+1作为右边的左边界]

//  移动枢纽元 划分
func movePovitPartition(nums []int, low, high, pivotType int) int {
	pivot := getPivot(nums, low, high, pivotType)
	i, j := low, high //左索引,右索引
	for {             //退出循环 1.可能出现i=j的情况，如果出现了，说明a[i/j]=pivot 2.可能i>j  i指向的元素大于等于pivot，j指向的小于等于pivot
		for nums[i] < pivot { // 只有i元素小于枢纽元的时候，才移动，否则停下来，包括i元素等于枢纽元时也停下来
			i++
		}
		for nums[j] > pivot {
			j--
		}
		if i < j {
			swap(nums, i, j)
			i++ // 继续移动i
			j-- // 继续移动j
		} else if i == j {
			break
		} else if i > j {
			break
		}
	}
	return i - 1 //return j 如果将枢纽元放在第一个元素上
}

## 快速排序 quick

- [上一章<<冒泡排序](../bubble)
- [下一章>>快速排序算法](../quick)
- [定义](#1)
- [算法来源](#2)
- [过程简单描述](#3)
- [图解](#4)
- [复杂度](#5)

// https://www.runoob.com/w3cnote/quick-sort.html
// https://www.jianshu.com/p/a68f72278f8f
// https://www.sohu.com/a/246785807_684445
// http://www.ayqy.net/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88quicksort%EF%BC%89%E8%A7%A3%E6%9E%90/
// https://www.imooc.com/article/37849

- <i id="1"></i>**`定义`**  


- <i id="2"></i>**`算法来源`**
`快速排序`也属于交换排序，是对[冒泡排序](../bubble)的一种改进。 [冒泡排序](../bubble) 在每一轮只把一个元素冒泡到数列的一端，`快速排序`在采用[分治法](../../../divide_conquer)，`每一轮挑选一个基准元素(pivot),并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。`
`快速排序`的前身是[归并](../../merge)，[归并](../../merge)的最大问题是需要额外的存储空间，并且由于合并过程不确定，致使每个元素在序列中的最终位置上不可预知的。
基本思想:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的索引数据都比另外一部分的所有数据都要小,然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。



- <i id="5"></i>**`复杂度`**  
1. 时间复杂度: 平均时间复杂度 O(nlogn) ,最坏情况下的时间复杂度是O(n^2) 随机选择pivot，每一次选到数列最大值或最小值。
2. 空间复杂度：快速排序使用[递归](../../../recursion),[递归](../../../recursion)使用栈，因此它的空间复杂度为O(logn)
3. 稳定性：`快速排序`无法保证相等的元素的相对位置不变，因此它是不稳定的排序算法
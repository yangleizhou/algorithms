## 快速排序 quick

- [上一章<<冒泡排序](../bubble)
- [下一章>>快速排序算法](../quick)
- [算法来源](#2)
- [过程简单描述](#3)
- [基准pivot选取](#4)
- [图解](#5)
- [复杂度](#6)

// https://www.runoob.com/w3cnote/quick-sort.html
// https://www.jianshu.com/p/a68f72278f8f
// https://www.sohu.com/a/246785807_684445
// http://www.ayqy.net/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88quicksort%EF%BC%89%E8%A7%A3%E6%9E%90/
// https://www.imooc.com/article/37849  
// https://wiki.jikexueyuan.com/project/data-structure-sorting/quick-sort.html 
// https://www.cnblogs.com/FdWzy/p/12288074.html



- <i id="2"></i>**`算法来源`**
`快速排序`也属于交换排序，是对[冒泡排序](../bubble)的一种改进。 [冒泡排序](../bubble) 在每一轮只把一个元素冒泡到数列的一端，`快速排序`在采用[分治法](../../../divide_conquer)，`每一轮挑选一个基准元素(pivot),并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。`
`快速排序`的前身是[归并](../../merge)，[归并](../../merge)的最大问题是需要额外的存储空间，并且由于合并过程不确定，致使每个元素在序列中的最终位置上不可预知的。
基本思想:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的索引数据都比另外一部分的所有数据都要小,然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

- <i id="3"></i>**`过程简单描述`**  
* 设当前待排序的无序区R[low..high],利用[分治法](../../../divide_conquer)可将快速排序分为：</br>
    1. 分解 
    在R[low..high]中任选一个记录作为基准(pivot),以此基准将当前无序区划分为左、右两个较小的区间R[low..pivotpos-1]和R[pivotpos+1..high],并使左边子区间中所有记录的关键字均小于等于`基准`(pivot)记录的关键字pivot.key,右边的子区间中所有记录的关键字均大于等于 pivot.key，而基准记录 pivot 则位于正确的位置(pivotpos)上，它无须参加后续的排序。
    2. 求解 
    通过[递归调用](../../../recursion)对左、右子区间R[low..pivotpos-1]和R[pivotpos+1..high]快速排序。</br>
    3. 组合 
    因为当"求解"步骤中的两个递归调用结束时，其左、右两个子区间已有序。对快速排序而言，"组合"步骤无须做什么，可看作是空操作。</br>
* 划分算法 Partition 
    1. 来回填坑法 </br>
    2. 算法导论方法 </br>
    3. 对换法 </br>

- <i id="5"></i>**`图解`**   
1. 设置两个变量low、high，排序开始的时候low = 0，high = n-1; </br>
2. 以第一个数组元素作为关键数据，赋值给pivot，即pivot：=A[0]; </br>
3. 从high开始向前搜索，即由后开始向前搜索，找到第一个小于pivot的值，两者交换; </br>
4. 从low开始向后搜索，即由前开始向后搜索，找到第一个大于pivot的值，两者交换; </br>
5. 重复第3、4步，直到low=high; </br>
![quick_sort](./quick_sort.gif)  </br>
图片来源网络</br>


- <i id="6"></i>**`复杂度`**  
1. 时间复杂度: 平均时间复杂度 O(nlogn) ,最坏情况下的时间复杂度是O(n^2) 随机选择pivot，每一次选到数列最大值或最小值。
2. 空间复杂度：快速排序使用[递归](../../../recursion),[递归](../../../recursion)使用栈，因此它的空间复杂度为O(logn)
3. 稳定性：`快速排序`无法保证相等的元素的相对位置不变，因此它是不稳定的排序算法.  
4. `快速排序`的性能在所有排序算法里面是最好的，数据规模越大快速排序的性能越优。快排在极端情况下会退化成O(n^2) 的算法，因此`假如在提前得知处理数据可能会出现极端情况的前提下`，可以选择使用较为稳定的[归并排序](../../merge)。
## 锦标赛排序(又称树形选择排序) tournament

- [上一章<<直接选择排序](../direct_selection)
- [下一章>>堆排序](../heap)
- [定义](#1)
- [过程简单描述](#2)
- [图解](#3)
- [复杂度](#4)
- [缺点](#5)



- <i id="1"></i>**`定义`**  
`锦标赛排序`，又称树形选择排序 ,首先对n个记录的关键字进行两两比较，得到 n/2 个比较的优胜者，将其作为第一次比较的结果保留下来；然后在n/2个较小者之间再进行两两比较，如此重复，直至选出最小的记录为止。

- <i id="2"></i>**`过程简单描述`**  
1. n个元素两两比较得到 n/2 个 比较的优胜者(更小的)保留下来, 再对这n/2个元素两两比较, ……直至选出一个最小的元素为止。 如果n不是2的K次幂，则让叶结点数补足到满足2^(k-1) < n <= 2^k 。在补足的时候，我们默认用最大的元素填充。
2. 输出最的元素。 再进行调整： 即把叶子结点上，该最小元素改为最大值后，再进行由底向上的比较，直至找到一个最小的元素（即次小元素）为止。
3. 重复2，直至把所有元素排好序。

- <i id="3"></i>**`图解`**
![img_tourmament](./img_tourmament.png)
图片来源于网络

- <i id="4"></i>**`复杂度`**  
1. 时间复杂度：O(nlogn)
    由于含有 n 个叶子结点的完全二叉树的深度为，则在树形选择排序中，除了最小关键字外，每选择一个次小关键字仅需进行 次比较，故时间复杂度为 O(nlogn)。



- <i id="5"></i>**`缺点`**  
 1. 与“∞”（最大值）的比较多余； 
 2. 辅助空间使用多。
 3. 为了弥补这些缺点，1964年，堆排序诞生。